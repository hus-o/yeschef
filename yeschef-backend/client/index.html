<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>YesChef Live Test</title>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
        .controls { margin: 20px 0; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        #status { font-weight: bold; margin-bottom: 10px; }
        #log { background: #f0f0f0; padding: 10px; border: 1px solid #ccc; height: 300px; overflow-y: scroll; white-space: pre-wrap; }
        .error { color: red; }
        .success { color: green; }
    </style>
</head>
<body>
    <h1>YesChef Live Mode Test</h1>
    
    <div>
        <label>Recipe ID: <input type="text" id="recipeId" value="" placeholder="UUID from DB"></label>
    </div>

    <div class="controls">
        <button id="connectBtn">Connect</button>
        <button id="disconnectBtn" disabled>Disconnect</button>
    </div>
    
    <div id="status">Status: Disconnected</div>
    
    <div>
        <h3>Audio/Video</h3>
        <p>Microphone access required. Audio will be streamed to Gemini.</p>
    </div>

    <div id="log"></div>

    <script>
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const recipeIdInput = document.getElementById('recipeId');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');

        let ws = null;
        let mediaStream = null;
        let audioProcessor = null;
        let audioContext = null;

        function log(msg, type='') {
            const el = document.createElement('div');
            el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            if (type) el.className = type;
            logDiv.appendChild(el);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        async function startAudio() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                audioContext = new AudioContext({ sampleRate: 16000 }); // Gemini prefers 16k
                const source = audioContext.createMediaStreamSource(mediaStream);
                const processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                processor.onaudioprocess = (e) => {
                    if (!ws || ws.readyState !== WebSocket.OPEN) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    // Convert float32 to int16 PCM
                    const buffer = new ArrayBuffer(inputData.length * 2);
                    const view = new DataView(buffer);
                    for (let i = 0; i < inputData.length; i++) {
                        let s = Math.max(-1, Math.min(1, inputData[i]));
                        s = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        view.setInt16(i * 2, s, true); // Little endian
                    }
                    
                    // Send as base64
                    const base64Audio = btoa(String.fromCharCode(...new Uint8Array(buffer)));
                    ws.send(JSON.stringify({ audio: base64Audio }));
                };

                source.connect(processor);
                processor.connect(audioContext.destination);
                audioProcessor = processor;
                log("Microphone started", "success");
            } catch (e) {
                log("Microphone error: " + e.message, "error");
            }
        }

        function stopAudio() {
            if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
            if (audioContext) audioContext.close();
            mediaStream = null;
            audioProcessor = null;
            audioContext = null;
        }

        let nextStartTime = 0;

        function playResponseAudio(base64Data) {
            if (!audioContext) return;
            
            // Decode Base64 to binary
            const binaryString = atob(base64Data);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const pcmData = new Int16Array(bytes.buffer);

            // Convert Int16 to Float32
            const floatData = new Float32Array(pcmData.length);
            for (let i = 0; i < pcmData.length; i++) {
                floatData[i] = pcmData[i] / 32768.0;
            }

            // Create AudioBuffer (Assuming 24kHz matching Gemini default)
            const buffer = audioContext.createBuffer(1, floatData.length, 24000);
            buffer.getChannelData(0).set(floatData);

            // Schedule playback
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);

            if (nextStartTime < audioContext.currentTime) {
                nextStartTime = audioContext.currentTime;
            }
            source.start(nextStartTime);
            nextStartTime += buffer.duration;
        }

        connectBtn.onclick = async () => {
            const uuid = recipeIdInput.value.trim();
            if (!uuid) return alert("Enter Recipe ID");
            
            connectBtn.disabled = true;
            statusDiv.textContent = "Status: Connecting...";
            
            ws = new WebSocket(`ws://localhost:8000/live/${uuid}`);
            
            ws.onopen = async () => {
                log("Connected", "success");
                statusDiv.textContent = "Status: Connected";
                disconnectBtn.disabled = false;
                
                await startAudio();
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.text) {
                    log("Gemini: " + data.text);
                }
                if (data.audio) {
                    playResponseAudio(data.audio);
                }
            };
            
            ws.onclose = (e) => {
                log(`Disconnected (Code: ${e.code}, Reason: ${e.reason})`, "error");
                statusDiv.textContent = "Status: Disconnected";
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                stopAudio();
            };
            
            ws.onerror = (e) => {
                log("WebSocket Error", "error");
            };
        };

        disconnectBtn.onclick = () => {
            if (ws) ws.close();
        };
    </script>
</body>
</html>
